Perfect‚Äîthanks for the answers. Below is a tight, copy-paste patch set for Replit that:

swaps multi-emotion ‚Üí single ‚Äútag‚Äù (red highlight),

adds a hover popover with a trash button to remove a tag,

on Save Entry opens the Release screen if any text is tagged,

renames Catharsis ‚Üí Release in the UI (keeps backend field name for now),

shows a Release folder listing all entries with tag counts; clicking an entry opens Release for that entry,

allows removal in both New/View screens (your #8).

You don‚Äôt have to delete any old code; these are incremental changes.

1) Editor: replace emotions with a single ‚Äútag‚Äù (red highlight + hover delete)

File: client/src/components/RetroJournalEditor.tsx
(Replace the current file contents with this version or merge the changed parts.)

import React, { forwardRef, useEffect, useImperativeHandle, useMemo, useRef, useState } from "react";
import { EditorContent, useEditor, BubbleMenu } from "@tiptap/react";
import StarterKit from "@tiptap/starter-kit";
import Underline from "@tiptap/extension-underline";
import Heading from "@tiptap/extension-heading";
import Placeholder from "@tiptap/extension-placeholder";
import { Mark, mergeAttributes, Extension } from "@tiptap/core";
import 'tippy.js/dist/tippy.css';

export type RetroJournalEditorHandle = {
  focus: () => void;
  insertParagraph: () => void;
  insertText: (text: string) => void;
  getHTML: () => string;
};

type Props = {
  value?: string;
  onChange?: (html: string) => void;
  placeholder?: string;
  className?: string;
};

/** Single generic tag mark -> <span data-tag="1">‚Ä¶</span> */
const TagMark = Mark.create({
  name: "tag",
  inclusive: true,
  group: "inline",
  inline: true,
  spanning: true,
  parseHTML() { return [{ tag: 'span[data-tag]' }, { tag: 'span[data-emotion]' }]; }, // backward compat
  renderHTML({ HTMLAttributes }) {
    // Normalize old data-emotion into data-tag on render
    const attrs = { ...HTMLAttributes };
    if (!attrs['data-tag']) attrs['data-tag'] = '1';
    delete (attrs as any)['data-emotion'];
    return ['span', mergeAttributes(attrs), 0];
  },
  addCommands() {
    return {
      toggleTag:
        () =>
        ({ chain, editor }) => {
          const active = editor.isActive(this.name);
          if (active) return chain().unsetMark(this.name).run();
          return chain().setMark(this.name, { 'data-tag': '1' } as any).run();
        },
      unsetTag:
        () =>
        ({ chain }) =>
          chain().unsetMark(this.name).run(),
    };
  },
});

/** Ctrl/Cmd+U shortcut for underline */
const UnderlineShortcuts = Extension.create({
  name: "underlineShortcuts",
  addKeyboardShortcuts() {
    return { "Mod-u": () => this.editor.commands.toggleUnderline() };
  },
});

const RetroJournalEditor = forwardRef<RetroJournalEditorHandle, Props>(
({ value = "<p></p>", onChange, placeholder = "Start writing your journal‚Ä¶", className }, ref) => {
  const editor = useEditor({
    extensions: [
      StarterKit.configure({
        bulletList: { keepMarks: true },
        orderedList: { keepMarks: true },
      }),
      Underline,
      UnderlineShortcuts,
      Heading.configure({ levels: [1, 2, 3] }),
      Placeholder.configure({ placeholder }),
      TagMark,
    ],
    content: value?.trim() ? value : "<p></p>",
    onUpdate: ({ editor }) => onChange?.(editor.getHTML()),
  });

  useImperativeHandle(ref, () => ({
    focus: () => { editor?.commands.focus(); },
    insertParagraph: () => { editor?.chain().focus().insertContent("<p></p>").run(); },
    insertText: (text: string) => { editor?.chain().focus().insertContent(text).run(); },
    getHTML: () => editor?.getHTML() ?? "",
  }), [editor]);

  // --- Bubble helpers
  const eat = (e: React.SyntheticEvent) => { e.preventDefault(); e.stopPropagation(); };
  const run = (fn: () => boolean) => (e: React.MouseEvent | React.FormEvent) => {
    e.preventDefault(); e.stopPropagation();
    editor?.chain().focus();
    fn();
  };

  // --- Hover delete popover for tagged spans
  const [hoverRect, setHoverRect] = useState<DOMRect | null>(null);
  const [hoverEl, setHoverEl] = useState<HTMLElement | null>(null);

  useEffect(() => {
    if (!editor) return;
    const dom = editor.view.dom as HTMLElement;

    const onOver = (ev: MouseEvent) => {
      const t = ev.target as HTMLElement;
      const el = t?.closest?.('span[data-tag], span[data-emotion]') as HTMLElement | null;
      if (el) {
        setHoverEl(el);
        setHoverRect(el.getBoundingClientRect());
      } else {
        setHoverEl(null);
        setHoverRect(null);
      }
    };
    const onScroll = () => {
      if (hoverEl) setHoverRect(hoverEl.getBoundingClientRect());
    };

    dom.addEventListener('mousemove', onOver);
    window.addEventListener('scroll', onScroll, true);
    return () => {
      dom.removeEventListener('mousemove', onOver);
      window.removeEventListener('scroll', onScroll, true);
    };
  }, [editor, hoverEl]);

  const removeThisTag = () => {
    if (!editor || !hoverEl) return;
    const view = editor.view;
    try {
      const from = view.posAtDOM(hoverEl, 0);
      const to = view.posAtDOM(hoverEl, hoverEl.childNodes.length);
      editor.chain().setTextSelection({ from, to }).unsetMark('tag').run();
      setHoverEl(null);
      setHoverRect(null);
    } catch { /* ignore */ }
  };

  if (!editor) return null;

  return (
    <div className={`retro-editor-shell ${className ?? ""}`}>
      <BubbleMenu
        editor={editor}
        tippyOptions={{ duration: 120, placement: "top", appendTo: () => document.body }}
      >
        <div className="bubble" onMouseDown={eat}>
          <button type="button" className={editor.isActive("bold") ? "active" : ""} onMouseDown={eat} onClick={run(() => editor.chain().toggleBold().run())}>B</button>
          <button type="button" className={editor.isActive("italic") ? "active" : ""} onMouseDown={eat} onClick={run(() => editor.chain().toggleItalic().run())}>I</button>
          <button type="button" className={editor.isActive("underline") ? "active" : ""} onMouseDown={eat} onClick={run(() => editor.chain().toggleUnderline().run())}>U</button>
          <div className="sep" />
          <button type="button" className={editor.isActive("bulletList") ? "active" : ""} onMouseDown={eat} onClick={run(() => editor.chain().toggleBulletList().run())} title='Bullet list'>‚Ä¢‚Ä¢</button>
          <div className="sep" />
          <select className="h-select" defaultValue="p" onMouseDown={eat}
            onChange={(e) => { e.preventDefault(); e.stopPropagation();
              const v = e.target.value;
              if (v === "p") editor.chain().focus().setParagraph().run();
              else editor.chain().focus().setHeading({ level: Number(v) as 1|2|3 }).run();
              e.currentTarget.value = "p";
            }}>
            <option value="p">Normal</option>
            <option value="1">H1</option>
            <option value="2">H2</option>
            <option value="3">H3</option>
          </select>
          <div className="sep" />
          <button type="button" className={editor.isActive("tag") ? "active" : ""} onMouseDown={eat} onClick={run(() => editor.commands.toggleTag())} title="Tag selection">Tag</button>
        </div>
      </BubbleMenu>

      {/* Hover delete popover */}
      {hoverRect && (
        <div
          className="tag-popover"
          style={{
            position: 'fixed',
            top: Math.max(8, hoverRect.top - 28),
            left: hoverRect.left,
            zIndex: 99999,
          }}
          onMouseDown={eat}
          onClick={(e) => { e.preventDefault(); e.stopPropagation(); }}
        >
          <button type="button" className="tag-popover-btn" onClick={removeThisTag} title="Remove tag">üóëÔ∏è Remove</button>
        </div>
      )}

      <div className="editor-surface" onMouseDown={(e) => e.stopPropagation()} onPointerDown={(e) => e.stopPropagation()}>
        <EditorContent editor={editor} />
      </div>
    </div>
  );
});

export default RetroJournalEditor;


File: client/src/index.css (append styles)

/* Tag (red highlight) ‚Äî applies in editor & viewer */
[data-tag], [data-emotion] {
  background: #ffe5e5;
  outline: 1px solid #d22;
  border-radius: 2px;
  padding: 0 1px;
}

/* Bubble menu already exists ‚Äî ensure it's above windows */
.tippy-box { z-index: 99999 !important; }

/* Hover delete popover for tags */
.tag-popover { background:#fff; border:1px solid #999; border-radius:6px; padding:4px 6px; box-shadow:0 2px 6px rgba(0,0,0,.2); }
.tag-popover-btn { font-size:12px; border:1px solid #777; background:#eee; cursor:pointer; padding:2px 6px; }

2) Save ‚Üí auto open ‚ÄúRelease‚Äù screen when tagged text exists

We‚Äôll extract tags from HTML (both new [data-tag] and old [data-emotion]) on save, store them under your existing catharsis field (no backend changes), and open Release if any exist.

File: client/src/pages/journal.tsx (or wherever handleSubmit and mutations live)

Add helper near the top:

function extractReleaseItemsFromHtml(html: string) {
  const out: Array<{ id: string; text: string; stressLevel: 'tag'; createdAt: string }> = [];
  if (!html) return out;
  const doc = new DOMParser().parseFromString(html, 'text/html');
  const nodes = Array.from(doc.querySelectorAll('[data-tag], [data-emotion]')) as HTMLElement[];
  const now = new Date().toISOString();
  nodes.forEach((el, idx) => {
    const text = (el.textContent || '').trim();
    if (!text) return;
    out.push({
      id: `release-${Date.now()}-${idx}`,
      text,
      stressLevel: 'tag',
      createdAt: now,
    });
  });
  return out;
}


In handleSubmit (before building the payload):

const releaseItems = extractReleaseItemsFromHtml(content);


Build the payload (keep the existing backend field catharsis):

const entryData: InsertJournalEntry = {
  title,
  content, // full HTML with <span data-tag>
  tags: tags.split(',').map(t => t.trim()).filter(Boolean),
  mood,
  journalDate,
  catharsis: releaseItems, // store for Release
};


In both createMutation.onSuccess(newEntry) and updateMutation.onSuccess() after your current invalidateQueries:

if (releaseItems.length > 0) {
  openReleaseWindow((newEntry?.id ?? currentEntryId)!, releaseItems);
}


Add this helper where you manage windows:

function openReleaseWindow(entryId: string, items: any[]) {
  const id = `release-${entryId}`;
  const z = typeof allocZ === 'function' ? allocZ() : 3000;
  setWindows(prev => [
    ...prev.filter(w => w.id !== id),
    {
      id,
      type: 'release' as const,
      title: 'Release',
      position: { x: 120, y: 90 },
      size: { width: 680, height: 520 },
      zIndex: z,
      entryId,
      payload: { items },
    },
  ]);
}


This keeps your storage simple (still catharsis) but the UI says ‚ÄúRelease‚Äù.

3) Rename desktop folder ‚ÄúCatharsis‚Äù ‚Üí ‚ÄúRelease‚Äù and list entries with counts

A) Rename the icon label
Wherever you define desktop icons (e.g., client/src/pages/desktop.tsx or similar), change:

// from:
{ id: 'catharsis', title: 'Catharsis', icon: 'folder', onOpen: openReleaseFolder }
// to:
{ id: 'release', title: 'Release', icon: 'folder', onOpen: openReleaseFolder }


B) Implement a simple Release folder window
Create a component that lists all entries with count of tagged snippets (scans content HTML). Clicking a row opens the Release window for that entry.

File: client/src/components/ReleaseFolder.tsx (new)

import { useQuery } from "@tanstack/react-query";
import { apiRequest } from "@/lib/queryClient";

function countTags(html: string) {
  if (!html) return 0;
  const doc = new DOMParser().parseFromString(html, 'text/html');
  return doc.querySelectorAll('[data-tag], [data-emotion]').length;
}

export default function ReleaseFolder({ onOpenRelease }: { onOpenRelease: (entryId: string) => void }) {
  const { data, isLoading } = useQuery({
    queryKey: ['/api/journal-entries'],
    queryFn: () => apiRequest('GET', '/api/journal-entries').then(r => r.json()),
    staleTime: 0,
  });

  if (isLoading) return <div className="p-2 text-xs">Loading‚Ä¶</div>;
  const entries = Array.isArray(data) ? data : [];

  const rows = entries
    .map((e: any) => ({ id: e.id, title: e.title || '(untitled)', count: countTags(e.content || '') }))
    .filter(r => r.count > 0)
    .sort((a, b) => b.count - a.count);

  return (
    <div className="p-2 text-xs" style={{ fontFamily: 'ChicagoFLF, Geneva, Arial, sans-serif' }}>
      <div className="mb-2 font-bold">Release items by entry</div>
      {rows.length === 0 ? (
        <div>No tagged text found.</div>
      ) : (
        <ul className="space-y-1">
          {rows.map(r => (
            <li key={r.id}>
              <button
                className="mac-link"
                onClick={() => onOpenRelease(r.id)}
                title="Open Release"
                style={{ textDecoration: 'underline' }}
              >
                {r.title}
              </button>
              <span> ‚Äî {r.count} tagged</span>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}


Wire this to your window manager where you open the folder:

function openReleaseFolder() {
  const id = 'release-folder';
  const z = typeof allocZ === 'function' ? allocZ() : 2500;
  setWindows(prev => [
    ...prev.filter(w => w.id !== id),
    {
      id,
      type: 'release-folder' as const,
      title: 'Release',
      position: { x: 80, y: 80 },
      size: { width: 520, height: 420 },
      zIndex: z,
      payload: {},
    },
  ]);
}


And render ReleaseFolder in that window (pass a handler that calls openReleaseWindow(entryId, extractReleaseItemsFromHtml(entry.content)) after fetching that entry; or simply navigate to your existing Release view for that entry).

4) Allow tag removal in View Entry too

If your View window renders HTML (not TipTap), add a light hover delete like the editor:

File: client/src/components/SafeHtml.tsx (or your viewer component)

import DOMPurify from 'dompurify';
import { useEffect, useRef } from 'react';

export default function SafeHtml({ html, onRemoveTag }: { html: string; onRemoveTag?: (newHtml: string) => void }) {
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const el = ref.current;
    if (!el || !onRemoveTag) return;

    const onClick = (e: MouseEvent) => {
      const t = e.target as HTMLElement;
      const tagEl = t?.closest?.('span[data-tag], span[data-emotion]') as HTMLElement | null;
      if (tagEl && (t.closest('.tag-popover-btn') || t.getAttribute('data-action') === 'remove-tag')) {
        e.preventDefault();
        // unwrap the span: replace it with its textContent
        const text = tagEl.textContent || '';
        tagEl.replaceWith(document.createTextNode(text));
        onRemoveTag(el.innerHTML);
      }
    };
    el.addEventListener('click', onClick);
    return () => el.removeEventListener('click', onClick);
  }, [onRemoveTag]);

  return <div ref={ref} className="rte-view" dangerouslySetInnerHTML={{ __html: DOMPurify.sanitize(html) }} />;
}


Then, in your View window, pass onRemoveTag={(newHtml) => updateMutation.mutate({ content: newHtml })} to persist the change.

(You can also add a little absolutely-positioned üóëÔ∏è button on hover using the same approach as the editor if you want UI parity‚Äîoptional.)

Final quick checks for you

Highlight text ‚Üí click Tag in the bubble ‚Üí it turns red.

Hover tagged text ‚Üí small Remove popover appears ‚Üí clicking it removes the tag.

Save Entry ‚Üí if any tags exist, a Release window opens.

Desktop folder reads Release, opens a list of entries with counts; clicking an entry opens Release for that entry.

In View Entry, tagged text shows red and you can remove tags (and it saves).

If anything behaves differently on your machine, tell me which file + ~10 surrounding lines and I‚Äôll patch that spot precisely.
What’s causing the gap (in your code)

You’re dragging the whole window (ref on .mac-window) and likely computing from the event target, not the window’s rect, so the first move “snaps.”

The window is position:absolute inside some parent; if that parent is offset/scrolling/has transforms, pointer coords don’t match.

.dragging { z-index: 1002 } can break your central z-stack and cause weird hops.

Fix: precise pointer math + title-bar drag + fixed positioning
1) Replace your drag hook with this (accurate dx/dy, pointer capture, scale-safe)

Create/replace /client/src/hooks/useDraggable.ts:

import { useCallback, useRef, useState } from "react";

type Pos = { x: number; y: number };

export function useDraggable(opts: {
  getElement: () => HTMLElement | null;    // window element (not the titlebar)
  onDrag: (pos: Pos) => void;              // pass clamped left/top to parent
  onDragStart?: () => void;
  onDragEnd?: () => void;
  clamp?: (pos: Pos) => Pos;               // optional bounds clamp
  scale?: number;                          // desktop zoom (default 1)
}) {
  const { getElement, onDrag, onDragStart, onDragEnd, clamp, scale = 1 } = opts;
  const [isDragging, setIsDragging] = useState(false);
  const start = useRef({ dx: 0, dy: 0 });
  const ptrId = useRef<number | null>(null);

  const onPointerDown = useCallback((e: React.PointerEvent) => {
    const el = getElement();
    if (!el) return;
    const rect = el.getBoundingClientRect();
    // distance between pointer and window's top-left (account for zoom)
    start.current.dx = (e.clientX - rect.left) / scale;
    start.current.dy = (e.clientY - rect.top) / scale;

    ptrId.current = e.pointerId;
    el.setPointerCapture(e.pointerId);
    setIsDragging(true);
    onDragStart?.();

    // prevent accidental text selection while dragging
    (document.body.style as any).userSelect = "none";
  }, [getElement, onDragStart, scale]);

  const onPointerMove = useCallback((e: React.PointerEvent) => {
    if (!isDragging) return;
    const el = getElement();
    if (!el) return;

    let x = e.clientX / scale - start.current.dx;
    let y = e.clientY / scale - start.current.dy;

    const next = clamp ? clamp({ x, y }) : { x, y };
    onDrag({ x: Math.round(next.x), y: Math.round(next.y) });
  }, [isDragging, getElement, clamp, onDrag, scale]);

  const onPointerUp = useCallback((e: React.PointerEvent) => {
    if (!isDragging) return;
    const el = getElement();
    if (el && ptrId.current != null) el.releasePointerCapture(ptrId.current);
    ptrId.current = null;
    setIsDragging(false);
    onDragEnd?.();
    (document.body.style as any).userSelect = "";
  }, [isDragging, onDragEnd, getElement]);

  return { onPointerDown, onPointerMove, onPointerUp, isDragging };
}

2) Patch MacWindow.tsx to drag from the title bar only, clamp to viewport, and avoid z-index fights
import { ReactNode, useMemo, useRef } from "react";
import { useDraggable } from "@/hooks/useDraggable";
import { useMacSounds } from "@/hooks/useMacSounds";

interface MacWindowProps {
  title: string;
  children: ReactNode;
  position: { x: number; y: number };
  size: { width: number; height: number };
  zIndex: number;
  onClose: () => void;
  onFocus: () => void;
  onPositionChange: (position: { x: number; y: number }) => void;
  onSizeChange?: (size: { width: number; height: number }) => void;
  'data-testid'?: string;
}

export default function MacWindow({
  title,
  children,
  position,
  size,
  zIndex,
  onClose,
  onFocus,
  onPositionChange,
  onSizeChange,
  'data-testid': testId
}: MacWindowProps) {
  const { playSound } = useMacSounds();
  const winRef = useRef<HTMLDivElement>(null);

  // Keep the window fully inside viewport
  const clamp = useMemo(() => {
    return ({ x, y }: { x: number; y: number }) => {
      const maxX = Math.max(0, window.innerWidth  - size.width);
      const maxY = Math.max(0, window.innerHeight - size.height);
      return { x: Math.min(Math.max(0, x), maxX), y: Math.min(Math.max(0, y), maxY) };
    };
  }, [size.width, size.height]);

  const drag = useDraggable({
    getElement: () => winRef.current,
    onDrag: (p) => onPositionChange(clamp(p)),
    onDragStart: () => { onFocus(); playSound('click'); },
    clamp,
    // scale: parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--app-scale') || '1')
  });

  const handleClose = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    playSound('windowClose');
    onClose();
  };

  const handleMinimize = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();
    playSound('click');
    // TODO: Implement minimize
  };

  return (
    <div
      ref={winRef}
      className={`mac-window`}
      style={{
        position: 'fixed',                 // <— fixed so math matches clientX/Y
        left: `${position.x}px`,
        top: `${position.y}px`,
        width: `${size.width}px`,
        height: `${size.height}px`,
        zIndex
      }}
      onMouseDownCapture={onFocus}         // bring to front before any drag
      data-testid={testId}
    >
      <div
        className="mac-window-title-bar"
        onPointerDown={drag.onPointerDown} // <— drag from titlebar only
        onPointerMove={drag.onPointerMove}
        onPointerUp={drag.onPointerUp}
      >
        <div className="mac-window-title">{title}</div>
        <div className="mac-window-controls">
          <button
            className="mac-window-control"
            onClick={handleMinimize}
            onMouseDown={(e) => e.stopPropagation()}
            data-testid="button-minimize"
          >
            -
          </button>
          <button
            className="mac-window-control"
            onClick={handleClose}
            onMouseDown={(e) => e.stopPropagation()}
            data-testid="button-close"
          >
            ×
          </button>
        </div>
      </div>
      <div className="mac-window-content">{children}</div>

      {/* resize handles unchanged */}
      {onSizeChange && (
        <>
          <div className="mac-window-resize-handle nw" onMouseDown={(e) => handleResize(e, 'nw')} data-testid="resize-nw" />
          <div className="mac-window-resize-handle ne" onMouseDown={(e) => handleResize(e, 'ne')} data-testid="resize-ne" />
          <div className="mac-window-resize-handle sw" onMouseDown={(e) => handleResize(e, 'sw')} data-testid="resize-sw" />
          <div className="mac-window-resize-handle se" onMouseDown={(e) => handleResize(e, 'se')} data-testid="resize-se" />
          <div className="mac-window-resize-handle n"  onMouseDown={(e) => handleResize(e, 'n')}  data-testid="resize-n" />
          <div className="mac-window-resize-handle s"  onMouseDown={(e) => handleResize(e, 's')}  data-testid="resize-s" />
          <div className="mac-window-resize-handle e"  onMouseDown={(e) => handleResize(e, 'e')}  data-testid="resize-e" />
          <div className="mac-window-resize-handle w"  onMouseDown={(e) => handleResize(e, 'w')}  data-testid="resize-w" />
        </>
      )}
    </div>
  );

  function handleResize(e: React.MouseEvent, direction: string) {
    if (!onSizeChange) return;
    e.preventDefault(); e.stopPropagation();

    const startX = e.clientX;
    const startY = e.clientY;
    const startW = size.width;
    const startH = size.height;
    const startXPos = position.x;
    const startYPos = position.y;

    const onMove = (ev: MouseEvent) => {
      const dx = ev.clientX - startX;
      const dy = ev.clientY - startY;

      let newW = startW;
      let newH = startH;
      let newX = startXPos;
      let newY = startYPos;

      if (direction.includes('e')) newW = Math.max(320, startW + dx);
      if (direction.includes('s')) newH = Math.max(220, startH + dy);
      if (direction.includes('w')) { newW = Math.max(320, startW - dx); newX = startXPos + (startW - newW); }
      if (direction.includes('n')) { newH = Math.max(220, startH - dy); newY = startYPos + (startH - newH); }

      // clamp to viewport
      const maxX = Math.max(0, window.innerWidth  - newW);
      const maxY = Math.max(0, window.innerHeight - newH);
      newX = Math.min(Math.max(0, newX), maxX);
      newY = Math.min(Math.max(0, newY), maxY);

      onSizeChange!({ width: newW, height: newH });
      onPositionChange({ x: newX, y: newY });
    };

    const onUp = () => {
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
    };

    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  }
}

3) CSS tweaks
/* Make the window math predictable and avoid “gap” from layout shifts */
.mac-window {
  /* was absolute —> use fixed so clientX/Y matches viewport coords */
  position: fixed;
  background: var(--mac-white);
  border: 2px outset #c0c0c0;
  box-shadow: 2px 2px 4px rgba(0,0,0,.3);
  min-width: 300px;
  min-height: 200px;
  /* remove cursor:move here (drag from titlebar only) */
}

/* drag from titlebar only */
.mac-window-title-bar {
  background: #f0f0f0;
  height: 28px;
  border-bottom: 1px inset #c0c0c0;
  display: flex; align-items: center; padding: 0 8px;
  cursor: move;
  user-select: none; /* prevents selecting title while dragging */
}

/* remove z-index bump; your z-stack manager should control order */
.dragging { opacity: .85; /* no z-index here */ }


If you render windows into a portal (recommended), ensure the layer is topmost:

#window-root { position: fixed; inset: 0; z-index: 2147483000; }

Responsive behavior (mobile/tablet friendly)

A. Fullscreen mode on small screens (no dragging)

@media (max-width: 900px) {
  .mac-window {
    left: 0 !important; top: 0 !important;
    width: 100vw !important; height: 100vh !important;
    border-radius: 0;
  }
  .mac-window-title-bar { cursor: default; }
}


B. Fluid sizes on desktop

.mac-window {
  width: clamp(360px, 70vw, 960px);
  height: clamp(260px, 70vh, 720px);
}


C. Keep in bounds when the user resizes the browser (put this in your window manager, once):

useEffect(() => {
  const onResize = () => {
    setWindows(ws => ws.map(w => {
      const maxX = Math.max(0, window.innerWidth  - w.size.width);
      const maxY = Math.max(0, window.innerHeight - w.size.height);
      return { 
        ...w, 
        position: { 
          x: Math.min(w.position.x, maxX), 
          y: Math.min(w.position.y, maxY) 
        } 
      };
    }));
  };
  window.addEventListener('resize', onResize);
  return () => window.removeEventListener('resize', onResize);
}, []);

Why this removes the “gap”

We compute the grab offset from the window’s bounding rect at pointerdown.

We drag using clientX/Y with position: fixed so there’s no scroll/offset mismatch.

Borders don’t change thickness on focus (no layout jump).

Titlebar-only dragging avoids offset differences when clicking deep children.

Optional scale param handles desktop zoom.

Try the patch above. If anything still feels off after pasting, send your useDraggable diff or a quick repro and I’ll tune the math to your exact stack.
1) New entry not showing in â€œSearch Entriesâ€

Goal: make the Search window refetch/reflect newly created/updated entries.

A) Make invalidation catch all journal-entry queries

File: client/src/pages/journal.tsx (where your create/update mutations live)

Replace each invalidateQueries call with a predicate so it also matches keys like ['/api/journal-entries', { q: '...' }], pages, etc.

// after create or update success:
queryClient.invalidateQueries({
  predicate: q =>
    Array.isArray(q.queryKey) &&
    String(q.queryKey[0]).startsWith('/api/journal-entries'),
});


Optionally, do a small optimistic cache merge for any â€œplain listâ€ cache:

// inside createMutation.onSuccess(newEntry)
queryClient.setQueryData(['/api/journal-entries'], (old: any) => {
  if (!old) return old;
  // If old is paginated shape {items:[], ...}, adjust accordingly
  if (Array.isArray(old)) {
    const exists = old.some((e: any) => e.id === newEntry.id);
    return exists ? old : [newEntry, ...old];
  }
  return old;
});

B) Make Search entries refetch by default

File (likely): client/src/components/SearchEntries.tsx (or wherever the list is rendered)

Ensure your query has no artificial staleTime and isnâ€™t enabled: false. Example:

const { data, isLoading } = useQuery({
  queryKey: ['/api/journal-entries', { q, page }],
  queryFn: () => apiRequest('GET', `/api/journal-entries?q=${encodeURIComponent(q)}&page=${page}`).then(r => r.json()),
  staleTime: 0,            // ensure it refetches after invalidation
  refetchOnWindowFocus: true,
});

2) Pipe emotion tags to a â€œReleaseâ€ window after Save (and rename UI)

Goal: when user hits Save Entry, if the editor content has emotion tags, open a Release window and pass those items. Also rename the UI from â€œCatharsisâ€ â†’ â€œReleaseâ€, but keep the DB field (catharsis) so you donâ€™t need backend changes.

A) Extract emotion tags from saved HTML

File: client/src/pages/journal.tsx

Add this helper near the top:

function extractReleaseItemsFromHtml(html: string) {
  const doc = new DOMParser().parseFromString(html || '', 'text/html');
  const nodes = Array.from(doc.querySelectorAll('[data-emotion]')) as HTMLElement[];
  const now = new Date().toISOString();
  return nodes
    .map((el, idx) => {
      const text = el.textContent?.trim() || '';
      const emotion = el.getAttribute('data-emotion') || '';
      if (!text || !emotion) return null;
      return {
        id: `release-${Date.now()}-${idx}`,
        text,
        stressLevel: emotion as 'angry' | 'sad' | 'anxious' | 'relieved',
        createdAt: now,
      };
    })
    .filter(Boolean) as Array<{
      id: string; text: string; stressLevel: 'angry' | 'sad' | 'anxious' | 'relieved'; createdAt: string;
    }>;
}

B) Include these items when saving and branch to â€œReleaseâ€

In your handleSubmit (same file), before building entryData:

const releaseItems = extractReleaseItemsFromHtml(content);


Build the payload (keep the field name catharsis for compatibility):

const entryData: InsertJournalEntry = {
  title,
  content,
  tags: tags.split(',').map(t => t.trim()).filter(Boolean),
  mood,
  journalDate,
  catharsis: releaseItems,   // <-- same backend field, new semantics
};


Then, in both createMutation.onSuccess and updateMutation.onSuccess, after the existing invalidate calls:

if (releaseItems.length > 0) {
  // open Release window with items and entryId (re-using your window manager)
  openReleaseWindow(newEntry?.id ?? currentEntryId!, releaseItems);
} else {
  // no tags: just keep in "Release" folder silently (UI wording change only)
}


Add this helper somewhere in journal.tsx where you open windows:

function openReleaseWindow(entryId: string, items: any[]) {
  const id = `release-${entryId}`;
  const z = typeof allocZ === 'function' ? allocZ() : 2000;
  setWindows(prev => [
    ...prev.filter(w => w.id !== id),
    {
      id,
      type: 'release' as const,
      title: 'Release',        // rename window title
      position: { x: 120, y: 90 },
      size: { width: 680, height: 520 },
      zIndex: z,
      entryId,
      payload: { items },      // pass emotion-tagged spans
    },
  ]);
}


You can keep your existing CatharsisWindow component but rename its title prop and accept payload.items; or create an alias component ReleaseWindow that wraps the same UI.

C) Rename visible strings from â€œCatharsisâ€ â†’ â€œReleaseâ€

In New Entry and View Entry windows, remove the Catharsis button entirely (see Â§3 below).

Wherever you render the left sidebar/folder list, change the label from Catharsis to Release. Do not change server field names.

3) Remove â€œCatharsisâ€ button in New Entry & View Entry

File: client/src/pages/journal.tsx (or the component that renders the footer buttons)

Delete or guard this block:

{/* Catharsis Button â€” REMOVE */}
{false && !readOnly && (
  <button
    type="button"
    className="mac-button catharsis-btn"
    onClick={() => setShowCatharsisWindow(true)}
    title="Open Catharsis Window"
    data-testid="button-catharsis"
  >
    Catharsis ({catharsisItems.length})
  </button>
)}


If catharsisItems state is unused after this, you can remove itâ€”but if you still display tags in the Release window, keep the state (renamed if you want) or rely on extractReleaseItemsFromHtml(content) whenever needed.

4) Sound On/Off toggle doesnâ€™t mute

Goal: centralize the sound toggle so every playSound() respects it.

A) Add a tiny sound settings provider

Create: client/src/hooks/useSoundSettings.tsx

import React, { createContext, useContext, useEffect, useState } from 'react';

type Ctx = { enabled: boolean; setEnabled: (v: boolean) => void; toggle: () => void; };
const SoundSettingsContext = createContext<Ctx | null>(null);

export function SoundSettingsProvider({ children }: { children: React.ReactNode }) {
  const [enabled, setEnabled] = useState<boolean>(() => {
    const raw = localStorage.getItem('soundEnabled');
    return raw ? raw === 'true' : true;
  });
  useEffect(() => { localStorage.setItem('soundEnabled', String(enabled)); }, [enabled]);
  const toggle = () => setEnabled(v => !v);
  return (
    <SoundSettingsContext.Provider value={{ enabled, setEnabled, toggle }}>
      {children}
    </SoundSettingsContext.Provider>
  );
}

export function useSoundSettings() {
  const ctx = useContext(SoundSettingsContext);
  if (!ctx) throw new Error('useSoundSettings must be used within SoundSettingsProvider');
  return ctx;
}


Wrap your app once (root layout) with the provider:

File: client/src/main.tsx or client/src/App.tsx (whichever mounts the app)

import { SoundSettingsProvider } from '@/hooks/useSoundSettings';

root.render(
  <SoundSettingsProvider>
    <App />
  </SoundSettingsProvider>
);

B) Make useMacSounds honor the switch

File: client/src/hooks/useMacSounds.ts

Add:

import { useSoundSettings } from '@/hooks/useSoundSettings';


Then inside the hook:

export function useMacSounds() {
  const { enabled } = useSoundSettings();
  // ... existing sound setup

  function playSound(name: 'type'|'click'|'success'|'trash'|'windowClose' /* add others */) {
    if (!enabled) return;           // <-- hard stop when muted
    // existing logic to play the audio buffer / HTMLAudioElement
  }

  return { playSound };
}


Now all existing calls like playSound('type') automatically respect the toggle.
Wire your â€œSound On/Offâ€ UI to useSoundSettings():

const { enabled, toggle } = useSoundSettings();
<button onClick={toggle}>{enabled ? 'Sound: On' : 'Sound: Off'}</button>


No changes needed elsewhere.

Quick verification checklist

Save a new entry â†’ open Search Entries â†’ it appears without reload.

Tag some text with ğŸ™‚ in the editor â†’ Save â†’ Release window opens with those tagged snippets; if no tags, no Release window.

No â€œCatharsisâ€ button present in New or View entry windows.

Flip Sound Off â†’ no key clicks / success sounds anywhere; flip On â†’ sounds return.

If you hit a specific file/location that doesnâ€™t match these paths, paste the path + the 10â€“15 lines around it and Iâ€™ll tailor the snippet exactly to your code.
1) index.css — remove native resizer glyphs + fix dragging z-index

Add these rules (near your window styles):

/* --- Disable native browser resizer glyphs (keep your custom handles) --- */
.mac-window,
.mac-window-content,
.rte-editable,
textarea {
  resize: none !important;                /* keep resizing via your custom handles only */
}

/* Hide WebKit's diagonal corner glyph if a browser still renders it */
.mac-window::-webkit-resizer,
.mac-window-content::-webkit-resizer,
.rte-editable::-webkit-resizer,
textarea::-webkit-resizer {
  display: none !important;
}

/* Optional: hide the scrollbar corner square that can look like a triangle */
.mac-window-content::-webkit-scrollbar-corner {
  background: transparent;
}

/* --- Dragging visual only: DO NOT change z-index here --- */
.dragging {
  opacity: 0.85;           /* keep the fade if you like */
  /* z-index: 1002;  <-- REMOVE any z-index here; the window manager controls order */
}


Also search your CSS for any stray resize: on window containers and remove it. Your custom .mac-window-resize-handle divs already provide resizing.

2) journal.tsx (or wherever you manage windows) — reliable “always on top” open behavior

Keep your current structure, but don’t rely on setTimeout and don’t hardcode z-index in CSS states. Use a simple monotonic counter and bump the window you open immediately.

Add/ensure these helpers:

// start high to avoid colliding with other app layers
const [nextZIndex, setNextZIndex] = useState(1000);

// Brings any window to front
function bringToFront(id: string) {
  setWindows(prev =>
    prev.map(w => (w.id === id ? { ...w, zIndex: nextZIndex + 1 } : w))
  );
  setNextZIndex(z => z + 1);
}

// Create or replace window and put it on top immediately
function openWindow(win: Win) {
  setWindows(prev => {
    const base = prev.filter(w => w.id !== win.id);
    return [...base, { ...win, zIndex: nextZIndex + 1 }];
  });
  setNextZIndex(z => z + 1);
}


Use them in your open handlers (no delays):

function handleNewEntry() {
  const id = `entry-${crypto.randomUUID()}`;
  openWindow({
    id,
    type: 'entry',
    title: 'New Journal Entry',
    /* position, size, etc */
  });
}

function handleSearchEntries() {
  openWindow({
    id: 'search',
    type: 'search',
    title: 'Search Entries',
    /* position, size, etc */
  });
}

function handleViewEntry(entryId: string, title: string) {
  openWindow({
    id: `view-${entryId}`,
    type: 'view',
    title: `View: ${title}`,
    entryId,
    /* position, size, etc */
  });
}


In MacWindow usage, keep this so any click focuses/raises:

<MacWindow
  /* ... */
  onFocus={() => bringToFront(window.id)}
/>


If any window still opens behind others, it’s usually a stacking context problem. Make sure all windows are siblings under the same parent and that parent doesn’t have transform, filter, or its own z-index lower than other layers. If needed, render them into a top layer:

<!-- index.html, inside <body> -->
<div id="window-root"></div>

/* global */
#window-root { position: fixed; inset: 0; z-index: 2147483000; }

// journal.tsx (render windows here via a portal)
createPortal(
  <div id="window-layer" style={{ position: 'fixed', inset: 0 }}>
    {windows
      .slice()                     // paint order by zIndex
      .sort((a, b) => (a.zIndex ?? 0) - (b.zIndex ?? 0))
      .map(w => (
        <MacWindow
          key={w.id}
          zIndex={w.zIndex}
          onFocus={() => bringToFront(w.id)}
          /* ...rest... */
        />
      ))}
  </div>,
  document.getElementById('window-root')!
);

3) MacWindow.tsx — no changes needed for resize logic

Your custom resize handles (.mac-window-resize-handle ...) will keep working. We’re only removing the native browser affordances; your JS-driven resizing remains intact.

Quick test checklist

Open Search Entries → it should appear on top.

Open New Entry → it should appear on top.

Drag any window → it should rise on mousedown (no CSS z-index bump).

Resize corners/edges → works; no diagonal WebKit triangles.

DevTools → confirm no element has a fixed z-index that overrides the manager.

Paste the above to Replit and you should be good. If anything still stacks wrong, tell me which container the windows are mounted under and I’ll tailor the fix to that DOM.